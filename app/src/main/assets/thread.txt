只有在原生方法执行期间及正在执行原生方法的线程环境下局部引用是有效的，局部引用不能在多线程间共享，
只有全局引用可以被多个线程共享。
被传递给每个原生方法的JNIEnv接口指针在与方法调用相关的线程中也是有效的，它不能被其它线程缓存或使用。
1.同步
与Java的同步类似，JNI的监视器允许原生代码利用Java对象同步，虚拟机保证存取监视器的线程能够安全执行，
而其它线程等待监视器对象变化可用状态。
// java同步代码块
synchronized(obj){
    // 同步线程安全代码块
}
在原生代码中，相同级别可以用jni的监视器方法实现。
// java同步代码块的原生等价
if(JNI_OK==env->MonitorEnter(obj)){
    //错误处理
}
// 同步线程安全代码块
if(JNI_OK==env->MonitorExit(obj)){
    //错误处理
}
2.原生线程
与了执行特定任务，这些原生构件可以并行使用原生线程。因为虚拟机不知道原生线程，因此它们不能与
java构件直接通信。为了与应用的依然活跃部分交互，原生线程应该先附着在虚拟机上。
JavaVM* cachedJvm;
// 将当前线程附着到虚拟机上
cacheJvm->AttachCurrentThread(&env,NULL);
// 可以用JNIEnv接口实现线程与Java应用程序的通信
// 将当前线程与虚拟机分离
cachedJvm->DetachCurrentThread();