RTTI
Run-Time Type Identification
通过运行类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。
RTTI提供了以下两个非常有用的操作符：
(1)typeid：返回指针和引用所指的实际类型；
(2)dynamic_cast：将基类类型的指针或引用安全地转换为派生类型的指针或引用。

android平台带有一个微型的C++运行库支持库，称为系统运行库。该运行库不支持以下特性：
(1)++标准库；
(2)异常支持；
(3)RTTI支持。
Android NDK提供了用于补充系统运行库功能的一些额外的C++运行库，以完善上述缺失的特性，这些C++运行库比较：
C++运行库    C++异常支持    C++ RTTI支持    C++标准库
系统库          No             No             No
GAbi++          No            Yes             No
STLport         No            Yes             Yes
GNU STL         Yes           Yes             Yes
(1)GAbi++ C++运行库
GAbi++ C++运行库是一个实验性的、最简化型的运行库，它提供建立在系统运行库所提供的相同特性基础上的RTTI支持。
它可以作为静态库或共享库使用。
(2)STLport C++运行库
STLport是一个开源的、多平台的C++标准库实现。它提供一个C++标准库头文件的完整集合以及对RTTI的支持。
STLport文档地址：www.stlport.org/doc
(3)GNU STL C++运行库
GUN标准C++库，也叫libstdc++-v3，是Android NDK中最全面的标准C++运行库。它是一个正在开发的、以实现ISO标准
C++库为目标的开源项目。在GNU标准C++库中，C++异常与C++ RTTI均被支持。如果原生代码确实需要任何一种特性，则需要通过构建系统变量进
行显式的声明。在Android NDK中，GNU标准C++库可作为静态库或共享库使用。
GUN STL文件地址：http://gcc.gnu.org/onlinedocs/libstdc++/

1.指定C++运行库
在模块build.gradle中添加：
方式一（未验证）
android {
    defaultConfig {
        ndk{
            stl "strport_shared"
        }
    }
}
方式二（未验证）
android {
    defaultConfig {
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=gnustl_static"
            }
        }
    }
}
stl支持的值有：
(1)system：默认的微型系统C++运行库，未设置时，默认采用该库
(2)gabi++_static：作为静态库的GAbi++运行库
(3)gabi++_shared：作为共享库的GAbi++运行库
(4)stlport_static：作为静态库的STLport运行库
(5)stlport_shared：作为共享库的STLport运行库
(6)gnustl_static：作为静态库的GNU STL运行库
(7)gnustl_shared：作为共享库的GNU STL运行库

2.静态运行库与动态运行库
除了系统运行库外，所有支持的C++运行库都同时提供静态库和共享库。应用程序开发人员可选择将他们的原生模块与
所需要的C++运行库进行静态或动态的链接。
(1)只有项目中包含单一的原生模块时支持静态库；
(2)项目中包含多个原生模块时推荐使用共享库。
当C++运行库以共享库的形式使用时，应用程序需要先加载需要的共享库，然后再加载依赖于此共享库的其它原生模块。
需要以逆序加载库文件，如下：
static{
    System.loadLibrary("strport_shared");
    Ststem.loadLibrary("module1");
    ...
}
这将在加载原生模块前加载strport_shared共享库，这样一来，在加载那些链接了C++运行库的模块时，C++运行库处于
可用状态。否则，对原生模块的加载将会失败。

3.添加C++异常支持与C++ RTTI支持
在模块build.gradle中添加：
android {
    defaultConfig {
        externalNativeBuild {
            cmake {
                cppFlags "-frtti -fexceptions"
            }
        }
    }
}

4.C++标准库基础之容器：序列
序列是一种大小可变的容器，它的元素都是线形排序的，C++标准库提供支持以下序列容器：
(1)vector：支持随机访问元素，它支持在末尾以常量时间插入和删除元素，在其它位置以线性时间插入和删除元素。
(2)deque：同vector类似，但除具备vector的结构属性外，还支持在序列开始的位置以常量时间插入和删除元素。这
   使得deque被选作实现队列的基础。
(3)list：双向链表，同时支持正向和反向遍历序列。
(4)slist：单向链表，只支持正向遍历序列。

5.C++标准库基础之容器：关联容器
关联容器是一种大小可变的容器，它支持通过键来高效地检索元素。关联容器内的每个元素都有一个对应的键。

6.C++标准库基础之关联容器：排序关联容器
排序关联容器按照区分大小写升序排序来存储键值，它可以保证大多数操作的复杂度绝不会超过数阶：
(1)set是一个已排序的简单关联容器，它的所有元素都已排序，而且没有任何两个元素是相同的；
(2)map是用唯一的键来保存关联数据的关联容器，它使用键值与元素关联，没有任何两个元素是相同的；
(3)multiset是一个已排序的、简单的、多重的关联容器，它的所有元素是已排序的，而且允许有重复的元素；
(4)multimap是一个已排序的、多重键值对的容器。它使用键值与元素关联，对拥有相同键值的元素数量不做限制。

7.C++标准库基础之关联容器：哈希关联容器
哈希关联容器是基于哈希表实现的，它对存储的元素不做排序。与排序关联容器相比，哈希关联容器的速度要快很多。
它可以保证大多数操作的最坏时间复杂度就是容器大小的线性操作复杂度。哈希关联容器的这个优势使得它特别适合
快速查询需要的元素。同排序关联容器相比，哈希关联容器不会对它的所存储的键值和元素做任何排序。
(1)hashed_set：简单的散列关联容器，它不允许存在重复的元素，最适合快速检查集合中的一个元素。
(2)hash_map：散列对关联容器，它将键和元素关联，而且可以通过这些键对元素进行快速查找，不管是键还是元素
   都没按照任何规则进行排序。
(3)hash_multiset：简单的散列多重关联容器，它允许容器中出现重复元素，同其它散列关联容器一样，它可以通
   过键来查找元素。
(4)hash_multimap：散列对多重关联容器，它将键和元素进行关联而且提供快速查找，它允许容器中出现多个元素
   对应同个键的情况。

8.C++标准库基础之容器：适配器
容器适配器用于在已有的基本容器类型的基础上提供专门的容器类型，一般通过限制已有的容器集合的功能来实现
专门类型的容器：
(1)stack：后进先出（LIFO）的数据结构，通过适配器限制deque的功能，并在deque的一端实现；
(2)queue：先进先出（FIFO）的数据结构，通过甜酸器限制deque的功能，并在deque的一端实现。

9.迭代器
迭代器可以对指定范围或一个容器内的对象进行迭代，它们是泛化的指针，它们被实现成为通用类的形式。
(1)Input iterator：用来读取它所引用元素的值。
(2)Output iterator：用于修改当前位置对象的值。
(3)Forward iterator：用于多种算法，因为它符合值的线性序列的常用概念，而且它前不规定输入或输出操作。
(4)Bidirectional iterator：可以用于向前或向后遍历给定范围的元素。
(5)Random access iterator：提供普通C指针算法的所有操作，它为以任意大小步幅遍历元素提供常量时间方法。

10.C++运行库的线程安全
所有的C++运行库实现都是线程安全的，也就是说共享容器的同时读操作是安全的，但是，如果线程既需要对共享容器
进行读操作，又需要进行写操作，则应用程序负责确保操作的互扩性。

11.C++运行库调度模式
C++运行库的性能已经进行优化，所以它们很少或根本不执行错误检查。GNU STL和STLport的C++运行库提供了调试模
式，使得检测对C++标准库错误的使用和隐藏在应用程序代码中的bug变得更容易。调试模式用语义上对等但安全的容
器和迭代器代替换不安全的标准容器和迭代器。以下是调试模式提供的调试工具。
(1)Safe iterator：追踪和连接着迭代器的容器。它们会执行迭代器的有效性和所有权的运行库校验。比如，向一个
   指向一个已被销毁的迭代器取值，只要存在这样的错误，在调试模式下就会被发现。
(2)Algorithm：预处理尝试验证输入的参数，并且只要存在错误就会被检测出来，算法预处理会用任何有效的附加信
   息又来验证，如迭代器在容器中的位置。

12.GNU STL调试模式
GNU STL C++运行库允许在指定的部分代码或整个应用程序下启动调试模式。
(1)使用单独的GNU STL调试容器
为了只为指定的部分代码启动调试模式，GNU STL用__gnu_debug命名空间代替std命名空间来为大多数的容器提供调试
模式启动副本。这些调试容器可以包含在头文件名加有debug前缀的子目录下，如下：
//包含调试vector容器
#include <debug/vector>
...
__gnu_debug::vector v;
使用单独的GNU STL调试容器需要修改代码，在大部分情况下这不是最优的选择。

13.启动GNU STL调试模式
GNU STL调试模式同样也可以在不需要修改源代码的情况下，在编译时启动。
//未验证
android {
    defaultConfig {
        externalNativeBuild {
            cmake {
                cppFlags "-d_glibcxx_debug"
            }
        }
    }
}

14.启动STLport调试模式
//未验证
android {
    defaultConfig {
        externalNativeBuild {
            cmake {
                cppFlags "-d_stlp_debug"
            }
        }
    }
}
